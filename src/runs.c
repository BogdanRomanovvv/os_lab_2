#include "timsort.h" // Заголовочный файл с определениями структур и функций
#include <stdlib.h>  // malloc, realloc, free
#include <string.h>  // memcpy, memmove (если используется)

/* ========== Управление массивом прогонов ========== */

// Функция инициализации динамического массива прогонов
// r - указатель на структуру массива прогонов
void runs_init(runs_array_t *r)
{
    r->data = NULL; // Изначально массив пустой (не выделена память)
    r->size = 0;    // Количество элементов = 0
    r->cap = 0;     // Вместимость массива = 0
}

// Функция добавления прогона в конец массива
// r - указатель на массив прогонов
// v - структура прогона (start, len) для добавления
void runs_push(runs_array_t *r, run_t v)
{
    if (r->size == r->cap) // Если массив заполнен полностью
    {
        // Вычисляем новую вместимость: удваиваем или 64 (для первого выделения)
        size_t nc = r->cap ? r->cap * 2 : 64;
        // Перевыделяем память с новой вместимостью (старые данные сохраняются)
        r->data = realloc(r->data, nc * sizeof(run_t));
        r->cap = nc; // Обновляем вместимость
    }
    r->data[r->size++] = v; // Добавляем элемент и увеличиваем размер
}

// Функция освобождения памяти массива прогонов
// r - указатель на массив прогонов
void runs_free(runs_array_t *r)
{
    if (r->data) // Проверяем, была ли выделена память
    {
        free(r->data);  // Освобождаем память массива
        r->data = NULL; // Обнуляем указатель для безопасности
    }
    r->size = 0; // Обнуляем размер
    r->cap = 0;  // Обнуляем вместимость
}

/* ========== Вычисление минимальной длины прогона ========== */

// Функция вычисления минимальной длины прогона (алгоритм TimSort)
// n - размер массива
// Возвращает минимальную длину прогона в диапазоне [32, 64]
// Гарантирует, что N/minrun близко к степени двойки для эффективного слияния
size_t min_run_length(size_t n)
{
    size_t r = 0;   // Флаг наличия младших битов
    while (n >= 64) // Пока n >= 64 (уменьшаем n до диапазона [32,63])
    {
        r |= (n & 1); // Запоминаем, если встретили нечётное число
        n >>= 1;      // Делим n на 2 (побитовый сдвиг вправо)
    }
    return n + r; // Возвращаем n + 1 если было нечётное, иначе n
}

/* ========== Обнаружение прогонов ========== */

// Функция обнаружения естественных прогонов в массиве
// ctx - контекст сортировки с массивом и его параметрами
// Алгоритм находит возрастающие/убывающие последовательности,
// разворачивает убывающие и расширяет короткие до minrun
void detect_runs(sort_context_t *ctx)
{
    int32_t *A = ctx->array;           // Указатель на массив для сортировки
    size_t N = ctx->array_size;        // Размер массива
    size_t minrun = min_run_length(N); // Вычисляем минимальную длину прогона
    size_t i = 0;                      // Текущая позиция в массиве

    while (i < N) // Проходим по всему массиву
    {
        size_t run_start = i; // Запоминаем начало текущего прогона
        i++;                  // Переходим к следующему элементу

        if (i == N) // Если это последний элемент массива
        {
            // Добавляем прогон из одного элемента
            runs_push(&ctx->runs, (run_t){run_start, 1});
            break; // Завершаем поиск прогонов
        }

        // Определение направления прогона (возрастающий или убывающий)
        if (A[i - 1] <= A[i]) // Если элементы упорядочены по возрастанию
        {
            // Возрастающий прогон: продолжаем пока элементы не убывают
            while (i < N && A[i - 1] <= A[i])
                ++i; // Расширяем прогон
        }
        else // Элементы упорядочены по убыванию
        {
            // Убывающий прогон: продолжаем пока элементы убывают
            while (i < N && A[i - 1] > A[i])
                ++i; // Расширяем убывающий прогон

            // Переворот прогона для получения возрастающего порядка
            size_t l = run_start, r = i - 1; // Левая и правая границы
            while (l < r)                    // Пока указатели не встретились
            {
                int32_t tmp = A[l]; // Временная переменная для обмена
                A[l++] = A[r];      // Меняем местами элементы
                A[r--] = tmp;       // и двигаем указатели к центру
            }
        }

        size_t run_len = i - run_start; // Вычисляем длину найденного прогона

        // Расширение короткого прогона до минимальной длины
        // Это нужно для эффективности слияния (избегаем много мелких прогонов)
        if (run_len < minrun) // Если прогон слишком короткий
        {
            // Вычисляем до какой длины расширить (minrun или до конца массива)
            size_t extend_to = (minrun < N - run_start) ? minrun : (N - run_start);
            // Сортируем расширенный участок методом вставок (эффективен для малых массивов)
            insertion_sort(A, run_start, run_start + extend_to);
            run_len = extend_to;     // Обновляем длину прогона
            i = run_start + run_len; // Обновляем текущую позицию
        }

        // Добавляем найденный прогон в массив прогонов
        runs_push(&ctx->runs, (run_t){run_start, run_len});
    }
}
